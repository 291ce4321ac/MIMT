function varargout = imhistFB(inpict,varargin)
%   IMHISTFB(INPICT,{NBINS},{OPTIONS})
%   COUNTS = IMHISTFB(...)
%   [COUNTS BINCENTERS] = IMHISTFB(...)
%   [COUNTS BINCENTERS BINEDGES] = IMHISTFB(...)
%   [COUNTS BINCENTERS BINEDGES HAX] = IMHISTFB(...)
%   Calculates the histogram counts for an image.  If called with no output arguments, a plot 
%   will be generated for visualization.
%
%   This used to be a passthrough to the IPT function imhist(), with an internal fallback implementation.
%   The passthrough functionality has since been removed due to conceptual problems with the way IPT imhist()
%   behaves.  In order to avoid the problems with imhist() and provide extended functionality, imhistFB()
%   no longer uses any IPT tools, and there should no longer be any expectations of identical behavior.
%
%   INPICT is an array of any standard image class. 
%      This array will be evaluated in whole without regards to its dimensionality, though it may 
%      not always make sense to do so for anything other than a 2D (i.e. single-channel) image.
%      Indexed images are not directly supported, but can be processed; see the webdocs.  Trying to pass 
%      a loose color table using the syntax from IPT imhist() will result in an error.
%   NBINS optionally specifies how many histogram bins should be used (scalar, default 256)
%      If the image class is 'logical', NBINS will always be 2, regardless of this setting.
%   OPTIONS include the keys and key-value pairs:
%     'style' controls what type of plot is generated (default 'stem')
%        'stem' generates a simple stem plot. This is the behavior of IPT imhist().
%        'bar' generates a bar plot, and may be preferable when NBINS is small.
%        'patch' generates a filled area plot, and may offer better readability due to reduced aliasing.
%     'range', followed by a 2-element vector specifies the interval over which to bin the data. 
%        By default, this is the standard data range implied by the image class.
%        (e.g. [0 255] for 'uint8')
%     'binalignment' controls how the data is binned. (default 'center')  
%        'center' places the end bins such that they are centered on the values specified
%           in RANGE.  Only half of each end bin overlaps with the interval specified by RANGE.  
%           This is the behavior of IPT imhist().
%        'edge' places the end bins such that their outermost edges lie on the values in RANGE.  
%           This means that each bin covers an equal portion of the interval in RANGE.
%        In both cases, the gradient stripe is drawn such that each segment of the gradient
%        is aligned with the corresponding histogram bin.  This is contrary to imhist() behavior.
%     'yscale' controls how the y-axis range is set (default 'tight')
%        'full' sets the y-axis limits such that all of the histogram peaks are fully visible.
%        'tight' is less sensitive to the presence of large peaks, mimicking imhist().
%     'parent', followed by an axes handle, explicitly specifies the parent axes.
%     'colortable', followed by a NBINSx3 color table, specifies the colors used in the gradient 
%        shown below the histogram.  If the length of the table is not NBINS, it will be interpolated.
%        While this might be able to be used with RANGE and NBINS for representing indexed-color images,
%        this is intended for pseudocolor representations of scaled data.  See cshist() for an example.
%        If not specified, a uniform gray map is used, where gray levels correspond to the relative 
%        positions of the corresponding bin centers, with respect to the limits in RANGE.  The specific 
%        gray levels generated by imhist() are miscalculated and do not correspond to the bin positions.
%     'invert' key optionally inverts the color gradient for use on inverted displays.
%     'forceplot' key optionally forces the creation of a plot, even when output arguments are requested.
% 
%  Optional output argument HAX contains two axes handles, one for the histogram, and one for the stripe.
%
% Webdocs: http://mimtdocs.rf.gd/manual/html/imhistFB.html
% See also: cshist, imhist, histc, histcounts

% i don't like the way the hist bins are centered on the extrema while the stripe bins aren't.
% also, the stripe's gray levels don't match the centers of _either_ binning strategy. 
% they're asymmetrically aligned with the upper edges of the stripe bins, which aren't even in the hist bins.
% it's confusing and ugly.  i don't know why it's that way, or if that's been fixed in newer versions.
% maybe it's an artifact of indexed image support?  but why?

% it would be better to avoid this awkward preservation of a bug.
% it's just about impossible to make imhistFB() have useful extended 
% functionality if it's forced to also replicate the dumb shit that imhist() does.
% make the 'centerbins' functionality control both the histogram and stripe breakpoints
% that way they _always_ correspond.

% https://www.mathworks.com/matlabcentral/answers/2120156-why-does-imhist-do-this

% this isn't a perfect replica of imhist()'s binning behavior.  
% the lower end bin isn't open in the same way (at least not with histcounts().  idk about histc())
% i don't know that i care to fix that.

% PARAMETERS
stylestr = {'bar','stem','patch'};
style = 'stem';
yscalestr = {'full','tight'};
yscale = 'tight';
binalignstr = {'center','edge'};
centerbins = true;
invert = false;
explicitCT = [];
N = 256;
barwidth = 1;
forceplot = false;

% DECLARATIONS (because i'm lazy and like (ab)using shared variables)
plotax = [];
stripeax = [];
CT = [];
xrange = [];
yrange = [];
plotaxpos0 = [];

inclass = class(inpict);
xrange = imclassrange(inclass);

if numel(varargin) ~= 0
	k = 1;
	while k <= numel(varargin)
		thisarg = varargin{k};
		if isnumeric(thisarg) 
			if isscalar(thisarg)
				N = round(thisarg);
			elseif ismatrix(thisarg) && size(thisarg,2) == 3
				error('IMHISTFB: indexed images are not supported')
			end
			k = k + 1;
		elseif ischar(thisarg)
			switch lower(thisarg)
				case 'style'
					nextarg = lower(varargin{k+1});
					if strismember(nextarg,stylestr)
						style = nextarg;
					else
						error('IMHISTFB: unsupported option for STYLE parameter')
					end
					k = k + 2;
				case 'parent'
					plotax = varargin{k+1};
					k = k + 2;
				case 'range'
					xrange = varargin{k+1};
					k = k + 2;
				case {'colortable','ct'}
					explicitCT = varargin{k+1};
					k = k + 2;
				case 'yscale'
					nextarg = lower(varargin{k+1});
					if strismember(nextarg,yscalestr)
						yscale = nextarg;
					else
						error('IMHISTFB: unsupported option for YSCALE parameter')
					end
					k = k + 2;
				case 'binalignment'
					nextarg = lower(varargin{k+1});
					if strismember(nextarg,binalignstr)
						if strcmp(nextarg,'edge')
							centerbins = false;
						end
					else
						error('IMHISTFB: unsupported option for BINALIGNMENT parameter')
					end
					k = k + 2;
				case 'invert'
					invert = true;
					k = k + 1;
				case 'forceplot'
					forceplot = true;
					k = k + 1;
				otherwise
					error('IMHISTFB: unknown key %s',thisarg)
			end
		else
			error('IMHISTFB: unrecognized argument')
		end
	end
end

% override N for logical inputs
% this is something that imhist() demands, but doesn't actually implement
% which forces the user to write wrappers around imhist() to do its input handling for it.
if islogical(inpict)
	N = 2; % wow that was so difficult.  
end

% imhist gives bin locations based on their centers, but histc/histcounts 
% need bin locations based on their edges, so we need to translate.
if centerbins
	% for centered bins
	os = 0.5*diff(xrange)/(N-1);
	breakpoints = linspace(xrange(1)-os,xrange(2)+os,N+1).';
	centers = linspace(xrange(1),xrange(2),N).';
else
	% for offset (uniform-width) bins
	os = 0.5*diff(xrange)/N;
	breakpoints = linspace(xrange(1),xrange(2),N+1).';
	centers = linspace(xrange(1)+os,xrange(2)-os,N).';
end

% base histogram tools are version-dependent
if ifversion('<','R2014b')
	% prior to R2014b
	counts = histc(inpict(:),breakpoints); %#ok<HISTC>
	counts(end-1) = sum(counts((end-1):end));
	counts = counts(1:end-1);	
else
	% R2014b onward
	counts = histcounts(inpict,breakpoints);
	counts = counts';
end


% plot if needed
doplot = (nargout == 0) || forceplot;
if doplot
	ploteverything();
end

% prepare outputs
switch nargout
	case 0
		% NOP
	case 1
		varargout{1} = counts;
	case 2
		varargout{1} = counts;
		varargout{2} = centers;
	case 3
		varargout{1} = counts;
		varargout{2} = centers;
		varargout{3} = breakpoints;
	case 4
		varargout{1} = counts;
		varargout{2} = centers;
		varargout{3} = breakpoints;
		if doplot
			varargout{4} = [plotax; stripeax];
		else
			varargout{4} = [];
		end
end



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function ploteverything()
	% generate the stripe CT if it's not provided
	if isempty(explicitCT)
		CT = imrescale(centers,xrange,[0 1]);
		CT = repmat(CT,[1 3]);
	else
		% if this isn't the right length, it needs to be interpolated
		N0 = size(explicitCT,1);
		if N0 == N
			CT = explicitCT;
		else
			x0 = linspace(0,1,N0);
			xf = linspace(0,1,N);
			CT = interp1(x0,explicitCT,xf,'linear');
		end
	end
	if invert
		CT = 1-CT;
	end

	% set up the axes
	if isempty(plotax)
		plotax = gca;
	end
	
	% calculate y-axis range
	switch yscale
		case 'full'
			yrange = [0 1.1*max(counts)];
			
		case 'tight'
			yrange = [0 2.5*sqrt(counts.'*counts/numel(counts))];
	end
	
	% imhist() will have negative ylim if this happens
	if sum(counts(:)) == 0
		yrange = [0 1];
	end
		
	% plot the histogram
	switch style
		case 'stem'
			drawstemstyle()
		case 'bar'
			drawbarstyle()
		case 'patch'
			drawpatchstyle()
	end
	
	% use a grid to separate us from the animals :)
	% i might make this optional, but the axes handles are available
	grid(plotax,'on');
	
	% set x-y axis scaling
	xlim(plotax,xrange);
	ylim(plotax,yrange);
	
	% imhist() also adds a colorbar
	% modify the axes used for the stem plot
	stripeh = 0.075; % same as imhist()
	set(plotax,'units','normalized');
	plotaxpos0 = get(plotax,'position');
	plotaxpos = plotaxpos0;
	plotaxpos(2) = plotaxpos(2) + stripeh*plotaxpos(4);
	plotaxpos(4) = (1-stripeh)*plotaxpos(4);
	set(plotax,'position',plotaxpos);
	set(plotax,'xticklabel','');
	
	% create a new axes for the color stripe
	stripeaxpos = plotaxpos0;
	stripeaxpos(4) = stripeh*plotaxpos0(4);
	stripeax = axes('parent',get(plotax,'parent'),'units','normalized', ...
				'position',stripeaxpos,'xlim',xrange,'ylim',[0 1]);
	
	% the x-position of the stripe pixel ("bin") centers
	if centerbins
		xstripe = xrange;
	else
		xstripe = imrescale([0 1] + [1 -1]/(2*N),[0 1],xrange);
	end
	
	% display the stripe
	CT = permute(CT,[3 1 2]); % shift from a Mx3x1 CT to a 1xMx3 image
	image(xstripe,[0 1],CT,'parent',stripeax);

	% reset things
	set(stripeax,'yticklabel','');
	xlim(stripeax,xrange)
	ylim(stripeax,[0 1])
	
	% leave things in a more convenient state
	set(get(plotax,'parent'),'currentaxes',plotax); % refocus the main axes
	set(plotax,'tag','imhistFB_plot'); % set tags like imhist() does, but actually set both
	set(stripeax,'tag','imhistFB_stripe');
	
	% set up the two axes so that they can be replaced/updated as one.
	% i'm just going to more or less do what imhist() does, 
	% but i'm not going to use the ipt-specific ui tools.
	link_and_prepare_axes()
end

function drawstemstyle()
	stem(plotax,centers,counts,'marker','none');
end

function drawbarstyle()
	hb = bar(plotax,centers,counts,barwidth);
	
	% this doesn't do anything in modern versions
	% but in older versions, bar() can inherit color from the _figure_ colormap
	% which leads to all sorts of stupid problems if you have other things in the figure.
	set(hb,'facecolor',[0 0.4470 0.7410]);
end

function drawpatchstyle()
	% vertices are at bin centers, except for padding vertices at the outer edges of the end bins.  
	% this keeps the stripe segments aligned correctly with the histogram bins.
	ytop = [0 counts.' 0]; % pad with zeros
	ybot = zeros(size(ytop)); % baseline is zero
	x = [breakpoints(1) centers.' breakpoints(end)]; % [edge centers edge]
	xc = imrescale(x,xrange,[0 1]); % color scale
	
	% construct patch object
    hp = patch([x fliplr(x)],[ybot fliplr(ytop)],[xc fliplr(xc)],'parent',plotax);
    set(hp,'EdgeColor','none');
    hold(plotax,'on'); 
    
    % plot envelope curve to make sure it's even visible
    plot(plotax,x,ytop,'k','linewidth',1);
    
    % set the colormap
	colormap(plotax,CT)
	
	% put a box around the axes just in case the patch sits atop it
	line(xrange([1 2 2 1 1]),yrange([1 1 2 2 1]),...
       'parent',plotax,'color',get(plotax,'xcolor'));
end

function link_and_prepare_axes()
	% link xlim/xtick properties
	h_link = linkprop([plotax,stripeax],{'xlim','xtick'});
	setappdata(stripeax,'stripe_link',h_link);

	% the deletion of this dummy object indicates when the parent axes
	% is cleared, but not necessarily deleted
	canary = text('parent',plotax,'visible','off','handlevisibility','off');
	
	% if plotax is cleared, but not deleted, get rid of stripeax
	% and reset plotax to its original geometry
	plotax_cleared_cbf = @(src,evt) reset_to_original_geometry();
	lis.plotaxcleared = addlistener(canary,'ObjectBeingDestroyed', plotax_cleared_cbf);
	
	% if plotax is deleted, just delete stripeax
	plotax_deleted_cbf = @(src,evt) removestripeax();
	lis.plotaxdeleted = addlistener(plotax,'ObjectBeingDestroyed', plotax_deleted_cbf);
	
	setappdata(stripeax,'imhistFB_Listeners',lis);
end

function removestripeax()
	if ishghandle(stripeax)
		delete(stripeax);
	end
end

function reset_to_original_geometry()
	removestripeax();
	set(plotax,'position',plotaxpos0,'tag','');
end


end % END MAIN SCOPE







